
## **1. Iterative Division *

**Idea:** Keep dividing `n` by 4 while it’s divisible. If you end at exactly `1`, it’s a power of four.

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        if (n <= 0) return false;
        while (n % 4 == 0) {
            n /= 4;
        }
        return n == 1;
    }
}
```

**Time Complexity:** `O(log₄ n)` — divides by 4 each loop.
**Space Complexity:** `O(1)` — no extra memory.

---

## **2. Using Logarithms (Mathematical)**

**Idea:**
If `n` is a power of 4, then `log₄(n)` must be an integer.
We use `Math.log(n) / Math.log(4)` and check if it’s whole.

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        if (n <= 0) return false;
        double val = Math.log(n) / Math.log(4);
        return val == (int) val;
    }
}
```

**Time Complexity:** `O(1)` — single calculation.
**Space Complexity:** `O(1)` — no extra memory.
⚠ **Caution:** Floating-point precision issues may occur for very large numbers.

---

## **3. Bitwise Method (Fastest, No Loops)**

**Idea:**

* A power of four is also a power of two **and** has its only `1` bit at an **even position** in binary.
* `(n & (n - 1)) == 0` → checks power of two.
* `(n & 0x55555555) != 0` → ensures the 1-bit is at an even position.

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n & 0x55555555) != 0;
    }
}
```

**Time Complexity:** `O(1)` — constant bitwise checks.
**Space Complexity:** `O(1)` — no extra memory.

If you want, I can draw you a **binary position diagram** showing exactly why the bitwise `0x55555555` mask works for powers of four. That’s an interview favorite.
