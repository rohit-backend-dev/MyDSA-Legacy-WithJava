# 153. Find Minimum in Rotated Sorted Array
---

## 📌 Problem Statement
Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times.  
For example:
- `[0,1,2,4,5,6,7]` → rotated 4 times → `[4,5,6,7,0,1,2]`
- `[0,1,2,4,5,6,7]` → rotated 7 times → `[0,1,2,4,5,6,7]`

Given the sorted rotated array `nums` of **unique elements**, return the **minimum element**.  
You must write an algorithm that runs in **O(log n)** time.

---

## 🚀 Approaches

### 1️⃣ Brute Force
- Traverse the array and keep track of the minimum.
- **Time Complexity:** `O(n)`
- **Space Complexity:** `O(1)`

#### 💻 Code
```java
class Solution {
    // Brute Force
    public int findMinBruteForce(int[] nums) {
        int min = Integer.MAX_VALUE;
        for (int num : nums) {
            if (num < min) {
                min = num;
            }
        }
        return min;
    }
}
```

---

### 2️⃣ Optimal (Binary Search)
- Use binary search to find the rotation point.
- Compare `nums[mid]` with `nums[high]`:
  - If `nums[mid] > nums[high]` → min lies in right half.
  - Else → min lies in left half (including `mid`).
- **Time Complexity:** `O(log n)`
- **Space Complexity:** `O(1)`

#### 💻 Code
```java
class Solution {
    // Optimal - Binary Search
    public int findMin(int[] nums) {
        int n = nums.length;
        int low = 0, high = n - 1;

        while (low < high) {
            int mid = (low + high) / 2;

            if (nums[mid] > nums[high]) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return nums[low];
    }
}
```

