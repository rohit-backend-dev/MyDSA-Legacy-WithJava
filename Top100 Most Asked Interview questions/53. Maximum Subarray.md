## **Problem**

Find the maximum possible sum of any **contiguous subarray** in `nums`.

---

## **Approach 1 – Brute Force**

### **Idea**

* A contiguous subarray can start at any index `i` and end at any index `j` where `i ≤ j`.
* Check **all possible subarrays**, compute their sums, and track the maximum.

### **Code**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int maxSum = Integer.MIN_VALUE;

        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                maxSum = Math.max(maxSum, sum);
            }
        }
        return maxSum;
    }
}
```

### **Complexity**

* **Time:** O(n²) – double loop
* **Space:** O(1) – no extra storage

---

## **Approach 2 – Optimized (Kadane’s Algorithm)**

### **Idea**

* Instead of recomputing sums, build the answer in one pass.
* At each element, decide:

  1. Start fresh from current element, or
  2. Extend the previous subarray.
* Keep track of the maximum sum found so far.

### **Code**

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        int currentSum = nums[0];
        int maxSum = nums[0];

        for (int i = 1; i < n; i++) {
            currentSum = Math.max(nums[i], currentSum + nums[i]); // start new or extend
            maxSum = Math.max(maxSum, currentSum); // track best
        }
        return maxSum;
    }
}
```

### **Complexity**

* **Time:** O(n) – single pass
* **Space:** O(1) – only a few variables

---
