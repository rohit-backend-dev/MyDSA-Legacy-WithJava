## **1️⃣ HashSet Approach**

```java
import java.util.HashSet;

class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        
        for (int num : nums) {
            if (set.contains(num)) { // O(1) average
                return true;
            }
            set.add(num); // O(1) average
        }
        
        return false;
    }
}
```

**Time Complexity**

* Looping through all elements: `O(n)`
* Each `set.contains()` and `set.add()` is **O(1)** on average.
* **Total**: **O(n)**

**Space Complexity**

* In worst case (all elements unique), set stores all `n` elements.
* **O(n)** extra space.

---

## **2️⃣ Sorting Approach**

```java
import java.util.Arrays;

class Solution {
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums); // O(n log n)
        for (int i = 0; i < nums.length - 1; i++) {
            if (nums[i] == nums[i + 1]) {
                return true;
            }
        }
        return false;
    }
}
```

**Time Complexity**

* Sorting: **O(n log n)**
* Single pass for adjacent duplicates: **O(n)**
* **Total**: **O(n log n)** (sorting dominates)

**Space Complexity**

* For **primitive arrays**, `Arrays.sort()` in Java uses **Dual-Pivot Quicksort** (in-place) → **O(1)** extra space.
* For **objects**, it uses **TimSort** → **O(n)** extra space, but here we have `int[]` so it’s **O(1)**.

---
