
## ðŸ”¹ Case 1: **LeetCode 83 â€“ Keep one copy**

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode curr = head;                // start from head node
        while (curr != null && curr.next != null) {  // loop until the end
            if (curr.val == curr.next.val) {        // if current and next have same value
                curr.next = curr.next.next;         // skip the duplicate node
            } else {
                curr = curr.next;                   // otherwise, move forward normally
            }
        }
        return head;                          // return updated head
    }
}
```

---


## ðŸ”¹ Case 2: **LeetCode 82 â€“ Remove all duplicates**

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0, head);  // dummy before head
        ListNode prev = dummy;                   // prev points to last non-duplicate node

        while (head != null) {                   // traverse list
            if (head.next != null && head.val == head.next.val) {
                // found duplicates, store the duplicate value
                while (head.next != null && head.val == head.next.val) {
                    head = head.next;            // skip all duplicates
                }
                prev.next = head.next;           // unlink duplicate sequence
            } else {
                prev = prev.next;                // no duplicate â†’ move prev
            }
            head = head.next;                    // move head forward always
        }

        return dummy.next;                       // return real head
    }
}
```


Do you want me to also **draw a step-by-step dry run diagram** for Case 2 (since itâ€™s trickier) so you can visualize how `prev`, `head`, and `dummy` move?
