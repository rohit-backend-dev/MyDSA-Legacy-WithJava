## ✅ **Solution 1: Using ArrayList + Sorting (Brute Force)**

```java
import java.util.*;

class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // Step 1: Collect values into an ArrayList
        List<Integer> arr = new ArrayList<>();
        ListNode temp1 = list1;
        ListNode temp2 = list2;

        while (temp1 != null) {
            arr.add(temp1.val);
            temp1 = temp1.next;
        }

        while (temp2 != null) {
            arr.add(temp2.val);
            temp2 = temp2.next;
        }

        // Step 2: Sort the ArrayList
        Collections.sort(arr);

        // Step 3: Convert sorted array back to a linked list
        return convert(arr);
    }

    // Helper method to build linked list from sorted values
    private ListNode convert(List<Integer> arr) {
        if (arr.isEmpty()) return null;

        ListNode head = new ListNode(arr.get(0));
        ListNode curr = head;

        for (int i = 1; i < arr.size(); i++) {
            curr.next = new ListNode(arr.get(i));
            curr = curr.next;
        }

        return head;
    }
}
```

### ⏱️ Time Complexity

* Traversing both lists: **O(m + n)**
* Sorting the array: **O((m + n) log(m + n))**
* Building new list: **O(m + n)**
  ➡ **Total: O((m + n) log(m + n))**

### 💾 Space Complexity

* ArrayList stores all elements: **O(m + n)**
* New linked list created: **O(m + n)**

---

## ✅ **Solution 2: Two-Pointer Merge (Optimal)**

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        // Dummy node to simplify result building
        ListNode dummyNode = new ListNode(-1);
        ListNode temp = dummyNode;

        ListNode temp1 = list1;
        ListNode temp2 = list2;

        // Merge while both lists are non-empty
        while (temp1 != null && temp2 != null) {
            if (temp1.val < temp2.val) {
                temp.next = temp1;   // link smaller node
                temp1 = temp1.next;  // move pointer forward
            } else {
                temp.next = temp2;
                temp2 = temp2.next;
            }
            temp = temp.next; // move merged list pointer
        }

        // Attach the remaining nodes (only one list may be non-null)
        if (temp1 != null) {
            temp.next = temp1;
        } else {
            temp.next = temp2;
        }

        // Return head of merged list
        return dummyNode.next;
    }
}
```

### ⏱️ Time Complexity

* Single traversal through both lists: **O(m + n)**

### 💾 Space Complexity

* No extra structures used, just pointers: **O(1)** (in-place merge)

---

⚡ **Key Difference**:

* **Array + Sort** → Simpler but slower (**O((m+n) log(m+n))**) and uses extra space.
* **Two-Pointer Merge** → Faster and optimal (**O(m+n)**), no extra space.
